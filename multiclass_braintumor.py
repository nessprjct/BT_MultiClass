# -*- coding: utf-8 -*-
"""multiclass_BrainTumor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1770H1Bh4mT4y3c7XS78vSiG7TQWUpo0k

# **DL Brain Tumor Classification**

# **Training and Saving the Model**
"""

# Get Dataset
!git clone https://github.com/nessprjct/DataSet.git

# Commented out IPython magic to ensure Python compatibility.
# %cd DataSet/Brain_tumor_lowData

!pwd

from keras.models import Sequential
from keras.layers import Activation
from keras.layers import Dense, Flatten # Changed import statement
from keras.optimizers import Adam
from keras.callbacks import TensorBoard, EarlyStopping
import keras.optimizers
from sklearn.metrics import classification_report
import keras.optimizers
from keras.applications import vgg16
import numpy as np
import random
import os
from tqdm import tqdm
import pickle
import cv2

# Define necessary constants
TEST_DIR = '/content/DataSet/Brain_tumor_lowData/Testing'
TRAIN_DIR = '/content/DataSet/Brain_tumor_lowData/Training'
IMG_SIZE = 128
CATEGORIES = ["glioma","meningioma","NO_Tumor","pituitary"]

"""**TRAIN**"""

# Creating training dataset
training_data = []

def create_training_data():
    for category in CATEGORIES:
        path = os.path.join(TRAIN_DIR,category)
        class_num = CATEGORIES.index(category)
        for img in tqdm(os.listdir(path)):
          img_array = cv2.imread(os.path.join(path,img) ,cv2.IMREAD_COLOR)
          # Check if img_array is None
          if img_array is not None:
            new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))
            training_data.append([new_array, class_num])
          else:
            print(f"Warning: Could not read image at {os.path.join(path,img)}")

    random.shuffle(training_data)

create_training_data()
#np.save('train_data.npy', training_data)
print(len(training_data))

print("train")
print()
X_train = np.array([i[0] for i in training_data]).reshape(-1,IMG_SIZE,IMG_SIZE,3)
Y_train = [i[1] for i in training_data]

pickle_out = open("X_train.pickle","wb")
pickle.dump(X_train, pickle_out)
pickle_out.close()

pickle_out = open("Y_train.pickle","wb")
pickle.dump(Y_train, pickle_out)
pickle_out.close()

"""**TEST**"""

# Creating testing dataset
testing_data = []

def create_testing_data():
    for category in CATEGORIES:
        path = os.path.join(TEST_DIR,category)
        class_num = CATEGORIES.index(category)

        for img in tqdm(os.listdir(path)):
          img_array = cv2.imread(os.path.join(path,img) ,cv2.IMREAD_COLOR)
          new_array = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))
          testing_data.append([new_array, class_num])

    random.shuffle(testing_data)

create_testing_data()
#np.save('testing_data.npy', testing_data)
print(len(testing_data))

print("testing")
print()
X_test= np.array([i[0] for i in testing_data]).reshape(-1,IMG_SIZE,IMG_SIZE,3)
Y_test = [i[1] for i in testing_data]

pickle_out = open("X_test.pickle","wb")
pickle.dump(X_test, pickle_out)
pickle_out.close()

pickle_out = open("Y_test.pickle","wb")
pickle.dump(Y_test, pickle_out)
pickle_out.close()

""" **VGG16**"""

# TRAIN MODEL

from keras.models import Sequential
from keras.layers import Activation
from keras.layers import Dense, Flatten # Changed import statement
from keras.optimizers import Adam
from keras.callbacks import TensorBoard, EarlyStopping
import keras.optimizers
from sklearn.metrics import classification_report
import keras.optimizers
from keras.applications import vgg16
import numpy as np

tensorboard = TensorBoard(log_dir='./VGG16logs', histogram_freq=0,
                          write_graph=True, write_images=False)
es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=5)

# We'll use VGG16 to quickly define a model
vgg16_model = vgg16.VGG16(include_top = False, input_shape = (IMG_SIZE,IMG_SIZE,3)) #Added include_top=False
vgg16_model.summary()
type(vgg16_model)



# Dropping last layers
model = Sequential()
for layer in vgg16_model.layers[:-3]:
    model.add(layer)


for layer in model.layers:
    layer.trainable = True

# Adding flatten layer to convert tensor into a vector
model.add(Flatten())

# Adding last Dense Layer
model.add(Dense(4,activation = 'softmax'))
model.summary()

model.compile(loss='sparse_categorical_crossentropy',
              optimizer= "adam",
              metrics=['accuracy'],
              )

X_train = X_train / 255.0
X_test = X_test / 255.0

Y_train = np.array(Y_train)
Y_test = np.array(Y_test)

history = model.fit(X_train, Y_train, batch_size=32, epochs=25)

# Evaluate the model
scores = model.evaluate(X_test, Y_test, verbose=1)
print('Test loss:', scores[0])
print('Test accuracy:', scores[1])

model.save("modelMC.h5") # replace model.h5 in "Runner"

y_pred = model.predict(X_test, batch_size=64, verbose=1)
y_pred_bool = np.argmax(y_pred, axis=1)
print(classification_report(Y_test, y_pred_bool))

"""# **Loading and Making Predictions**

---
"""

from keras.models import load_model
import cv2
import numpy as np
import matplotlib.pyplot as plt

# Define categories
CATEGORIES = ["glioma", "meningioma", "NO_Tumor", "pituitary"]

# Load the trained model
model = load_model("/content/DataSet/Brain_tumor_lowData/modelMC.h5")

# Function to predict image category
def predict_image(image_path):
    IMG_SIZE = 128
    img_array = cv2.imread(image_path, cv2.IMREAD_COLOR)
    if img_array is None:
        print("Error: Image not found!")
        return None
    resized_img = cv2.resize(img_array, (IMG_SIZE, IMG_SIZE))
    normalized_img = resized_img / 255.0
    input_image = np.expand_dims(normalized_img, axis=0)
    predictions = model.predict(input_image)
    predicted_class_index = np.argmax(predictions)
    predicted_category = CATEGORIES[predicted_class_index]
    return predicted_category, predictions[0]

# Example usage
test_image_path = "/content/Tr-gl_0010.jpg"  # Replace with your image path
predicted_category, confidence_scores = predict_image(test_image_path)

if predicted_category:
    print(f"Predicted Category: {predicted_category}")
    print(f"Confidence Scores: {confidence_scores}")

    # Display the image
    img = cv2.imread(test_image_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.imshow(img)
    plt.title(f"Predicted: {predicted_category}")
    plt.axis("off")
    plt.show()